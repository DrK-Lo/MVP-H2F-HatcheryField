---
title: "length_calc_field"
author: "Camille Rumberger"
date: "`r Sys.Date()`"
output: html_document
---

This script reads in raw field measurement data from the MVP Field Experiment
(2023–2025), merges tag-level length/width measurements with bag metadata, and
assigns monitoring events by date. 

Update by KEB: this script now performs all cleaning (population
renaming, dead/missing removal, outlier correction). These steps were previously conducted in analysis files, such as `Q1_field_performance_models.Rmd`. This script now produces two saved
data products used by all downstream scripts:

1. `field_length_all_times.csv` — individual-level cleaned lengths (all events)
2. `lengths_bags.csv` — bag-level mean lengths (all events)

It also computes population-level summaries and exploratory line plots (not saved).

### Load packages

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Set working directory relative to project root
knitr::opts_knit$set(root.dir = here::here())

if (!require("pacman")) install.packages("pacman")

packages <- c("here", "tidyverse", "lubridate")
pacman::p_load(char = packages)

# log versions for reproducibility
r_version <- paste(R.version$major, R.version$minor, sep = ".")
lib_ver <- packages %>%
  map_chr(~ paste0(.x, " (v", packageVersion(.x), ")")) %>%
  paste(collapse = ", ")
```

```{r}
getwd()
```

```{r}
bags <- read.csv("data/performance_H2F/MVP23-FieldBags-bags.csv")
tags <- read.csv("data/performance_H2F/MVP23-FieldBags-tags.csv")
tagleng <- read.csv("data/performance_H2F/MVP23-FieldBags-tagsLength.csv")

# extract pop and bag number from bags_label (format: MVP-POP-NUM)
bags <- bags %>%
  mutate(
    pop = str_split_fixed(bags_label, "-", 3)[, 2],
    bagnum = str_split_fixed(bags_label, "-", 3)[, 3]
  )

colnames(bags)[1:4] <- c("bags_key", "bag_site", "bags_label", "SpawnTrt_Key")

# remove practice bags (rows 61–62 in original data)
bags <- bags %>% filter(!str_detect(bags_label, "Practice"))

# merge tags -> bags -> tag lengths
tagsbags <- tags %>%
  left_join(bags, by = "bags_key") %>%
  left_join(tagleng, by = "tags_key") %>%
  dplyr::select(tags_label, tags_timestamp, bag_site, bags_label,
         pop, bagnum, length, width, tagsLength_timestamp) %>%
  filter(!is.na(bags_label))  # remove unmatched tags (no bag assignment)
```

## Prepare data

### Assign monitoring events by date

Monitoring event boundaries:
- Event 1: up to 2023-11-16
- Event 2: 2023-11-17 through 2024-05-09
- Event 3: after 2024-05-09

```{r assign-events}
tagsbags <- tagsbags %>%
  dplyr::mutate(
    tagsLength_date = mdy(str_split_fixed(tagsLength_timestamp, " ", 2)[, 1])
  ) %>%
  # remove practice date (2024-03-13) and rows with no measurement date
  filter(!is.na(tagsLength_date), tagsLength_date != as_date("2024-03-13")) %>%
  # assign monitoring event based on date boundaries
  dplyr::mutate(
    t = case_when(
      tagsLength_date <= as_date("2023-11-16") ~ 1L,
      tagsLength_date <= as_date("2024-05-09") ~ 2L,
      TRUE ~ 3L
    )
  ) %>%
  # remove non-population entries (site markers, empty strings)
  filter(!pop %in% c("", "LEW", "YORK"))

```

### Remove 0s, missing data, outliers

This section performs all cleaning that downstream scripts (such as `Q1_field_performance_models.Rmd`) previously did
independently. This made it so that we were using datasets that were filtered differently in different files. After these changes, this data should be analysis-ready for any downstream analysis -KEB.

```{r clean}
field_length <- tagsbags %>%
  # rename populations to standardized names
  mutate(pop = case_match(pop,
    "TX" ~ "W1-TX", "LA" ~ "W2-LA", "FL" ~ "W3-FL", "JR" ~ "W4-VA",
    "LOLA" ~ "S1-LOLA", "DEBY" ~ "S2-DEBY", "NH" ~ "W5-NH", "ME" ~ "W6-ME",
    "LARMIX" ~ "H1-HYBRIDMIX", "SEEDMIX" ~ "H2-SEEDMIX",
    .default = pop
  )) %>%
  # remove dead/missing oysters (length == 0)
  filter(length != 0) %>%
  # remove incomplete records (NA width)
  filter(!is.na(width))

# fix known data entry errors (order of magnitude off)
# one oyster recorded as 400mm length (should be 40.0) and
# one as 465mm width (should be 46.5)
n_len_fix <- sum(field_length$length == 400)
n_wid_fix <- sum(field_length$width == 465)
message(sprintf("Correcting %d length and %d width order-of-magnitude errors", n_len_fix, n_wid_fix))

field_length <- field_length %>%
  mutate(
    length = if_else(length == 400, 40.0, length),
    width = if_else(width == 465, 46.5, width)
  )

# set population factor order
field_length <- field_length %>%
  mutate(pop = factor(pop, levels = c(
    "W1-TX", "W2-LA", "W3-FL", "W4-VA", "S1-LOLA", "S2-DEBY",
    "W5-NH", "W6-ME", "H1-HYBRIDMIX", "H2-SEEDMIX"
  )))

message(sprintf("Clean dataset: %d individual measurements across %d populations, %d events",
                nrow(field_length), n_distinct(field_length$pop), n_distinct(field_length$t)))
```

## Save individual-level data product

This file is used by: `Q1_field_performance_models.Rmd`,
`Q2_envr_quantile_models_field.Rmd`, `Q2_envrdist_models_field.Rmd`,
`pairwise_differences_analyses.Rmd`.

```{r save-individual}
field_length %>%
  dplyr::select(bag_site, pop, t, bags_label, tags_label, length, width) %>%
  write.csv("data/performance_H2F/field_length_all_times.csv")
```

## Save bag-level means

Bag means are computed AFTER cleaning (dead removal, outlier correction),
so they reflect the same data used in downstream models.

```{r bag-means}
lengths_bags <- field_length %>%
  group_by(bags_label, t) %>%
  summarise(length = mean(length, na.rm = TRUE), .groups = "drop") %>%
  rename(bag = bags_label, monitoring_event = t)

write.csv(lengths_bags, "data/performance_H2F/lengths_bags.csv")
```

Now that I have prepared the data, I will look at some larger data trends and visualize some of these trends.

## Calculate population-level means

```{r pop-summaries}
# population means by site and event
pop_site_means <- field_length %>%
  group_by(bag_site, pop, t) %>%
  summarise(length = mean(length, na.rm = TRUE), .groups = "drop")

# overall population means (across sites)
pop_overall_means <- field_length %>%
  group_by(pop, t) %>%
  summarise(length = mean(length, na.rm = TRUE), .groups = "drop") %>%
  mutate(bag_site = "Overall")

# combine for plotting
pop_means_all <- bind_rows(pop_site_means, pop_overall_means)

# print summaries by site and event
for (s in c("Lewisetta", "YorkRiver")) {
  for (ev in 1:3) {
    cat(sprintf("\n--- %s, event %d ---\n", s, ev))
    pop_means_all %>%
      filter(bag_site == s, t == ev) %>%
      arrange(desc(length)) %>%
      print()
  }
}
```

### Exploratory plots

```{r plots, fig.width=10, fig.height=6}
# plotting config
pop_plot <- tibble(
  pop = levels(field_length$pop),
  order = 1:10,
  cols = c("#332288", "#117733", "#44AA99", "#88CCEE", "#DDCC77",
           "#CC6677", "#AA4499", "#882255", "black", "gray"),
  shape = c(21, 21, 21, 21, 23, 23, 21, 21, 24, 24)
)

make_length_plot <- function(data, site_name, title) {
  plot_data <- data %>%
    filter(bag_site == site_name) %>%
    left_join(pop_plot, by = "pop")

  ggplot(plot_data, aes(x = t, y = length,
                        color = fct_reorder(pop, order),
                        fill = fct_reorder(pop, order),
                        shape = fct_reorder(pop, order))) +
    geom_line() +
    geom_point(size = 4) +
    scale_color_manual(name = "Population", labels = pop_plot$pop, values = pop_plot$cols) +
    scale_fill_manual(name = "Population", labels = pop_plot$pop, values = pop_plot$cols) +
    scale_shape_manual(name = "Population", labels = pop_plot$pop, values = pop_plot$shape) +
    scale_x_continuous("Monitoring Event", breaks = 1:3,
                       labels = c("Fall '23", "Spring '24", "Fall '24")) +
    ylim(20, 80) +
    ylab("Shell Length (mm)") +
    ggtitle(title) +
    theme_classic() +
    theme(plot.title = element_text(size = 16),
          legend.title = element_text(size = 12),
          legend.justification = "top")
}

make_length_plot(pop_means_all, "Lewisetta", "Lewisetta: shell length through time")
make_length_plot(pop_means_all, "YorkRiver", "York River: shell length through time")
make_length_plot(pop_means_all, "Overall", "Overall: shell length through time")
```