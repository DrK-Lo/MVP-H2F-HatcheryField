---
title: "survival_calc_field"
author: "Camille Rumberger"
date: "`r Sys.Date()`"
output: html_document
---

This script calculates cumulative survival of oysters in the MVP Field
Experiment (2023–2025) from raw mortality count data.

Update by KEB: this script now performs all cleaning (population renaming,
bag_site attachment) that was previously done in `Q1_field_performance_models.Rmd`.
It produces one saved data product used by all downstream scripts:

1. `field_surv_all_times.csv` — bag-level cumulative survival (all events),
   with standardized population names and bag_site attached.

It also computes population- and site-level summary statistics and exploratory
line plots (not saved).

## Load packages

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Set working directory relative to project root
knitr::opts_knit$set(root.dir = here::here())

if (!require("pacman")) install.packages("pacman")

packages <- c("here", "tidyverse", "lubridate", "plotrix")
pacman::p_load(char = packages)

# log versions for reproducibility
r_version <- paste(R.version$major, R.version$minor, sep = ".")
lib_ver <- packages %>%
  map_chr(~ paste0(.x, " (v", packageVersion(.x), ")")) %>%
  paste(collapse = ", ")
```

```{r}
getwd()
```

## Read and merge raw data

```{r read-merge}
bags <- read.csv("data/performance_H2F/MVP23-FieldBags-bags.csv")
mort <- read.csv("data/performance_H2F/MVP23-FieldBags-mortality.csv")
spawntrt <- read.csv("data/performance_H2F/MVP23-FieldBags-spawn_trt2.csv")

# rename bag columns
colnames(bags) <- c("bags_key", "bag_site", "bags_label", "SpawnTrt_Key")

# merge bags -> mortality -> spawn treatment
mort_data <- bags %>%
  merge(mort, by = "bags_key", all = TRUE) %>%
  merge(spawntrt, by = "SpawnTrt_Key", all = TRUE) %>%
  dplyr::select(bags_key, bag_site, bags_label, SpawnTrt_Key, SpawnTrt_Label,
         mortality_key, mortality_label, mortality_timestamp,
         alive_count, dead_count, alive_returned)

# parse dates from mortality timestamp
mort_data <- mort_data %>%
  mutate(
    mortality_date = mdy(str_split_fixed(mortality_timestamp, " ", 2)[, 1])
  )

# remove practice rows
mort_data <- mort_data %>%
  filter(SpawnTrt_Label != "Practice")

# assign monitoring events using same boundaries as length script
mort_data <- mort_data %>%
  mutate(
    t = case_when(
      mortality_date <= as_date("2023-11-16") ~ 1L,
      mortality_date <= as_date("2024-05-09") ~ 2L,
      TRUE ~ 3L
    )
  )

# add bag order for survival calculation (needs consistent ordering)
bag_order <- mort_data %>%
  distinct(bags_label) %>%
  arrange(bags_label) %>%
  mutate(order = row_number())

mort_data <- mort_data %>%
  left_join(bag_order, by = "bags_label")
```

## Data quality checks

```{r quality-checks}
# alive count at event N should never exceed alive_returned from event N-1
check_consistency <- function(data, current_event, previous_event) {
  current <- data %>% filter(t == current_event) %>% arrange(order)
  previous <- data %>% filter(t == previous_event) %>% arrange(order)

  problems <- which(current$alive_count > previous$alive_returned)
  if (length(problems) > 0) {
    message(sprintf("Event %d: %d bags have more alive than returned from event %d:",
                    current_event, length(problems), previous_event))
    for (i in problems) {
      diff <- current$alive_count[i] - previous$alive_returned[i]
      message(sprintf("  %s: %d more oysters", current$bags_label[i], diff))
    }
  } else {
    message(sprintf("Event %d vs %d: all consistent.", current_event, previous_event))
  }
}

check_consistency(mort_data, 2, 1)
check_consistency(mort_data, 3, 2)
```

## Calculate cumulative survival

Survival is calculated as a proportion of those surviving from the previous
time point, accumulated across events.

```{r calc-survival}
surv_calc_bag <- function(dat, e) {
  dat_ord <- dat[order(dat$order), ]
  O <- dat_ord[dat_ord$t == e, ]$alive_count
  if (e - 1 < 1) {
    D <- (dat_ord[dat_ord$t == e, ]$alive_count) + (dat_ord[dat_ord$t == e, ]$dead_count)
    S <- 1
  } else {
    D <- dat_ord[dat_ord$t == (e - 1), ]$alive_returned
    S <- surv_calc_bag(dat_ord, (e - 1))$surv
  }
  survival <- (O / D) * S
  data.frame(bags_label = dat_ord[dat_ord$t == e, ]$bags_label, t = e, surv = survival)
}

surv_long <- bind_rows(
  surv_calc_bag(mort_data, 1),
  surv_calc_bag(mort_data, 2),
  surv_calc_bag(mort_data, 3)
)
```

## Clean and standardize

This section performs the cleaning that `Q1_field_performance_models.Rmd`
previously did: adding bag_site, extracting and renaming populations.

```{r clean}
# add bag_site from bags data
surv_clean <- surv_long %>%
  left_join(bags %>% dplyr::select(bags_label, bag_site), by = "bags_label")

# extract raw pop name from bags_label (format: MVP-POP-NUM)
surv_clean <- surv_clean %>%
  mutate(pop = str_split_fixed(bags_label, "-", 3)[, 2])

# rename populations to standardized names
surv_clean <- surv_clean %>%
  mutate(pop = case_match(pop,
    "TX" ~ "W1-TX", "LA" ~ "W2-LA", "FL" ~ "W3-FL", "JR" ~ "W4-VA",
    "LOLA" ~ "S1-LOLA", "DEBY" ~ "S2-DEBY", "NH" ~ "W5-NH", "ME" ~ "W6-ME",
    "LARMIX" ~ "H1-HYBRIDMIX", "SEEDMIX" ~ "H2-SEEDMIX",
    .default = pop
  ))

# reorder columns to match expected format for downstream scripts
field_surv <- surv_clean %>%
  dplyr::select(bag_site, pop, bags_label, t, surv)

message(sprintf("Survival dataset: %d bag-event observations, %d populations, %d events",
                nrow(field_surv), n_distinct(field_surv$pop), n_distinct(field_surv$t)))
```

## Save data product

This file is used by: `Q1_field_performance_models.Rmd`,
`Q2_envr_quantile_models_field.Rmd`, `Q2_envrdist_models_field.Rmd`,
`pairwise_differences_analyses.Rmd`.

```{r save}
write.csv(field_surv, "data/performance_H2F/field_surv_all_times.csv")
```

## Population- and site-level summary

```{r summaries}
# wide format survival by bag
surv_wide <- field_surv %>%
  pivot_wider(names_from = t, values_from = surv, names_prefix = "t") %>%
  mutate(t0 = 1)

# by population
pop_surv <- surv_wide %>%
  group_by(pop) %>%
  summarise(across(starts_with("t"), list(
    mean = ~mean(., na.rm = TRUE),
    sd = ~sd(., na.rm = TRUE),
    se = ~std.error(., na.rm = TRUE)
  ), .names = "{.col}_{.fn}"), .groups = "drop")
pop_surv

# by site
site_surv <- surv_wide %>%
  group_by(bag_site) %>%
  summarise(across(starts_with("t"), list(
    mean = ~mean(., na.rm = TRUE),
    sd = ~sd(., na.rm = TRUE),
    se = ~std.error(., na.rm = TRUE)
  ), .names = "{.col}_{.fn}"), .groups = "drop")
site_surv

# by site and population (long format for plotting)
site_pop_surv <- surv_wide %>%
  group_by(bag_site, pop) %>%
  summarise(across(starts_with("t"), list(
    mean = ~mean(., na.rm = TRUE),
    sd = ~sd(., na.rm = TRUE),
    se = ~std.error(., na.rm = TRUE)
  ), .names = "{.col}_{.fn}"), .groups = "drop")

# pivot to long for plotting
mort_df <- site_pop_surv %>%
  pivot_longer(
    cols = matches("^t\\d+_"),
    names_to = c("event", ".value"),
    names_pattern = "t(\\d+)_(mean|sd|se)"
  ) %>%
  mutate(event = as.integer(event)) %>%
  rename(mean_surv = mean)
```

## Exploratory plots

```{r plots, fig.width=10, fig.height=6}
pop_plot <- tibble(
  pop = c("W1-TX", "W2-LA", "W3-FL", "W4-VA", "S1-LOLA", "S2-DEBY",
          "W5-NH", "W6-ME", "H1-HYBRIDMIX", "H2-SEEDMIX"),
  order = 1:10,
  cols = c("#332288", "#117733", "#44AA99", "#88CCEE", "#DDCC77",
           "#CC6677", "#AA4499", "#882255", "black", "gray"),
  shape = c(21, 21, 21, 21, 23, 23, 21, 21, 24, 24)
)

make_surv_plot <- function(data, site_name, title) {
  plot_data <- data %>%
    filter(bag_site == site_name) %>%
    left_join(pop_plot, by = "pop")

  ggplot(plot_data, aes(x = event, y = mean_surv,
                        color = fct_reorder(pop, order),
                        fill = fct_reorder(pop, order),
                        shape = fct_reorder(pop, order))) +
    geom_line() +
    geom_point(size = 4) +
    scale_color_manual(name = "Population", labels = pop_plot$pop, values = pop_plot$cols) +
    scale_fill_manual(name = "Population", labels = pop_plot$pop, values = pop_plot$cols) +
    scale_shape_manual(name = "Population", labels = pop_plot$pop, values = pop_plot$shape) +
    scale_x_continuous("Monitoring Event", breaks = 0:3,
                       labels = c("Spring '23", "Fall '23", "Spring '24", "Fall '24")) +
    ylim(0, 1) +
    ylab("Survival") +
    ggtitle(title) +
    theme_classic() +
    theme(plot.title = element_text(size = 16),
          legend.title = element_text(size = 12),
          legend.justification = "top")
}

make_surv_plot(mort_df, "Lewisetta", "Lewisetta: oyster survival through time")
make_surv_plot(mort_df, "YorkRiver", "York River: oyster survival through time")
```