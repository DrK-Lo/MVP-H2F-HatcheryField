---
title: "pairwise_differences_analyses"
author: "Kiran Bajaj"
output: pdf_document
date: "`r Sys.Date()`"
---

This analysis tests whether pairwise environmental distance between conditions at the environments-of-origin or pairwise genetic distance (Fst) between parent populations predicts differences in survival and shell length.

## Load packages

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Set working directory relative to project root
knitr::opts_knit$set(root.dir = here::here())

if (!require("pacman")) install.packages("pacman")

packages <- c("here", "ggplot2", "tidyverse", "grid", "reshape2", "vegan", "patchwork")
pacman::p_load(char = packages)

# log versions for reproducibility
r_version <- paste(R.version$major, R.version$minor, sep = ".")
lib_ver <- packages %>%
  map_chr(~ paste0(.x, " (v", packageVersion(.x), ")")) %>%
  paste(collapse = ", ")
```

```{r}
getwd()
```

## Global variables
```{r config}
# save population display order
POP_ORDER <- c("W1-TX", "W2-LA", "W3-FL", "W4-VA", "S1-LOLA", "S2-DEBY", "W5-NH", "W6-ME")

# site name recoding from raw data to standardized names
SITE_RECODE <- c(
  "MVP-TX" = "W1-TX", "MVP-LA" = "W2-LA", "MVP-FL" = "W3-FL", "MVP-JR" = "W4-VA",
  "MVP-LOLA" = "S1-LOLA", "MVP-DEBY" = "S2-DEBY", "MVP-NH" = "W5-NH", "MVP-ME" = "W6-ME"
)

# groups to exclude from analysis (no environment-of-origin data available)
EXCLUDE_GROUPS <- c("H1-HYBRIDMIX", "H2-SEEDMIX", "MVP-LARMIX", "MVP-SEEDMIX")

```

## Helper functions
```{r helpers}
#' recode site names and filter excluded groups
clean_site_names <- function(df, site_col = "site_name") {
  df %>%
    filter(!.data[[site_col]] %in% EXCLUDE_GROUPS) %>%
    mutate(!!site_col := recode(.data[[site_col]], !!!SITE_RECODE))
}

#' reorder data frame by population order
order_by_pop <- function(df, site_col = "site_name") {
  df %>% arrange(factor(.data[[site_col]], levels = POP_ORDER))
}

#' create distance matrix from a two-column data frame (site_name, value)
make_dist_matrix <- function(df) {
  df <- df %>% filter(!site_name %in% EXCLUDE_GROUPS) %>% order_by_pop()
  stopifnot(identical(df$site_name, POP_ORDER))  # will error loudly if mismatch
  mat <- as.matrix(dist(df[[2]]))
  rownames(mat) <- colnames(mat) <- df$site_name
  mat
}

#' summarize field data by monitoring event and site
summarize_field_data <- function(df, value_col, group_col = "bag_site") {
  df %>%
    group_by(monitoring_event, .data[[group_col]], site_name) %>%
    summarise(value = mean(.data[[value_col]], na.rm = TRUE), .groups = "drop")
}

#' split field summary data into a list of named data frames 
#' one data frame per monitoring event per site per variable 
split_field_data <- function(df, prefix, group_col = "bag_site") {
  df %>%
    group_split(monitoring_event, .data[[group_col]]) %>%
    setNames(
      df %>%
        group_keys(monitoring_event, .data[[group_col]]) %>%
        mutate(name = paste0(prefix, "_event", monitoring_event, "_", 
                            tolower(gsub(" ", "", .data[[group_col]])))) %>%
        pull(name)
    ) %>%
    map(~ .x %>% order_by_pop() %>% dplyr::select(site_name, value))
}

#' create a heatmap from a distance matrix
plot_heatmap <- function(mat, fill_label, title = "") {
  as.data.frame(as.table(mat)) %>%
    ggplot(aes(Var1, Var2, fill = Freq)) +
    geom_tile(color = "white") +
    scale_fill_viridis_c(option = "D", na.value = "grey50",
                         guide = guide_colorbar(label.theme = element_text(angle = 45, size = 12))) +
    labs(title = title, x = "Treatment group", y = "Treatment group", fill = fill_label) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 14),
      axis.text.y = element_text(size = 14),
      axis.title = element_text(size = 14),
      legend.title = element_text(size = 14),
      legend.position = "bottom"
    )
}
```

## Load data
```{r load-data}
# raw lengths of all oysters aged 15-78 days
hatchery_length <- read.csv(file.path("data", "performance_H2F", "nursery_length.csv"))

# survival rate data for larval oysters up to day 21 post hatching
hatchery_survival <-  read.csv(file.path("data", "performance_H2F", "CViMVP_larvae_survival.csv"))

# Individual oyster measurements for field monitoring events 1-3
# Dead/missing oysters (length == 0) and incomplete records (NA width) removed
field_length <- read.csv(file.path("data", "performance_H2F", "field_length_all_times.csv"), row.names = 1)

# survival of all oysters averaged by bag for field monitoring events 1-3 #GET RIGHT FILE
field_survival <- read.csv(file.path("data", "performance_H2F", "field_surv_all_times.csv"), row.names = 1)

# summary statistics - temperature and salinity quantiles for the 8 groups 
envr_summary <-  read.csv(file.path("results", "environment", "envr_quantiles_summary.csv"))

# matrix of euclidean environmental distances using SCALED data
envr_dist <- readRDS(file.path("results", "environment", "envr_quantiles_dist.rds"))

# matrix of genetic distances between each group
fst_mat <- readRDS(file.path("results", "parental_genetics", "20250606_fst_results.rds"))

# reorder Fst matrix to match population order
fst_mat <- fst_mat[POP_ORDER, POP_ORDER]
```

```{r}


# Compute bag means from new individual-level data
new_bag_means <- field_length %>%
  group_by(bags_label, t) %>%
  summarise(new_mean = mean(length, na.rm = TRUE),
            n_new = n(), .groups = "drop") %>%
  arrange(bags_label, t)

# Load old bag means
old_data <- read.csv("data/performance_H2F/lengths_bags_022025.csv", row.names = 1)

# Join and compare
comparison <- old_data %>%
  rename(bags_label = bag, old_mean = length) %>%
  left_join(new_bag_means, by = c("bags_label", "monitoring_event" = "t")) %>%
  mutate(diff = round(new_mean - old_mean, 4))

# Show any mismatches
comparison %>% filter(abs(diff) > 0.001)

# If there are differences, it's the input data
# If they match perfectly, it's something in the downstream code

```

## Data preparation

### Hatchery data

For hatchery survival rate, we used survival from day 21, so filter for those values only. Days 15-21 were grouped for analysis because there were constant larval drops occurring during that time, but the number of drops varied by site. We exclude any groups with "small" in their label, as we only want to analyze eyed oysters. We also exclude HYBRIDMIX, since there is no environmental data for group, given that it represents oysters from multiple sites. 

```{r hatchery-data}
# survival at day 21  
surv_day21 <- hatchery_survival %>%
  filter(Day_analysis == "15-21", !grepl("small", Group_Day_Label, ignore.case = TRUE)) %>%
  clean_site_names("Tank_naming") %>%
  dplyr::select(site_name = Tank_naming, surv_21 = Survival_rate_perc) %>%
  order_by_pop()

# shell length at days 21 and 78
hatchery_length_clean <- hatchery_length %>%
  dplyr::select(site_name, day_an, shell_length_mm) %>%
  filter(!site_name %in% EXCLUDE_GROUPS)

calc_mean_length <- function(df, day) {
  df %>%
    filter(day_an == day) %>%
    group_by(site_name) %>%
    summarise(mean_length = mean(shell_length_mm), .groups = "drop") %>%
    order_by_pop()
}

means_mm_21 <- calc_mean_length(hatchery_length_clean, "15-21")
means_mm_78 <- calc_mean_length(hatchery_length_clean, "78")
```

### Field data

The goal is to summaraize data by monitoring event (3) and by each field site (2) with the average length across all bags for each treatment group. 

```{r field-data}
# clean field data: filter excluded groups, rename pop to site_name for consistency
clean_field <- function(df) {
  df %>%
    dplyr::filter(!.data[["pop"]] %in% EXCLUDE_GROUPS) %>%
    dplyr::rename(site_name = pop, monitoring_event = t)
}

# field length: two-step average (individual → bag mean → group mean)
field_length_list <- field_length %>%
  clean_field() %>%
  group_by(monitoring_event, bag_site, site_name, bags_label) %>%
  summarise(bag_mean = mean(length, na.rm = TRUE), .groups = "drop") %>%
  group_by(monitoring_event, bag_site, site_name) %>%
  summarise(value = mean(bag_mean, na.rm = TRUE), .groups = "drop") %>%
  split_field_data("len", "bag_site")

# field survival: already one row per bag, just average across bags per group
field_survival_list <- field_survival %>%
  clean_field() %>%
  group_by(monitoring_event, bag_site, site_name) %>%
  summarise(value = mean(surv, na.rm = TRUE), .groups = "drop") %>%
  split_field_data("surv", "bag_site")
```
### Environmental-of-origin
```{r envr-data}
# add sampling site latitudes from Table 1 of Nicole's thesis
envr <- envr_summary %>%
  mutate(lat = c(28.096, 29.240, 30.440, 37.150, 37.980, 37.249, 43.054, 44.013))
```

## Data product: hatchery survival, hatchery length, environment-of-origin
```{r export}
surv_length_envr <- envr %>%
  left_join(means_mm_21 %>% dplyr::rename(mean_length_mm_21 = mean_length), by = "site_name") %>%
  left_join(means_mm_78 %>% dplyr::rename(mean_length_mm_78 = mean_length), by = "site_name") %>%
  left_join(surv_day21, by = "site_name")

#write.csv(surv_length_envr, file.path("data", "parent_effects_H2F", "survival_length_envr_data.csv"), row.names = FALSE)
```

## Build distance matrices
```{r distance-matrices}
# combine all response variables into list
response_dfs <- c(
  list(surv_day21 = surv_day21 %>% dplyr::select(site_name, value = surv_21),
       len_21 = means_mm_21 %>% dplyr::rename(value = mean_length),
       len_78 = means_mm_78 %>% dplyr::rename(value = mean_length)),
  field_length_list,
  field_survival_list
)

# convert each to distance matrix
dist_matrices <- map(response_dfs, make_dist_matrix)

# verify all matrices have correct ordering
stopifnot(all(map_lgl(dist_matrices, ~ identical(rownames(.x), POP_ORDER))))
message("All matrices have correct row/column ordering.")
```

## Partial Mantel tests
```{r mantel-tests}
# test genetic distance effect (controlling for environment)
genetic_results <- map(dist_matrices, ~ mantel.partial(
  .x, fst_mat, envr_dist, method = "spearman", permutations = 10000, na.rm = TRUE
))

# test environmental distance effect (controlling for genetics)
envr_results <- map(dist_matrices, ~ mantel.partial(
  .x, envr_dist, fst_mat, method = "spearman", permutations = 10000, na.rm = TRUE
))

# extract p-values and apply FDR correction
genetic_p <- map_dbl(genetic_results, "signif")
envr_p <- map_dbl(envr_results, "signif")
all_p_adj <- p.adjust(c(genetic_p, envr_p), method = "BH")

# create results table
mantel_results <- tibble(
  test = rep(names(dist_matrices), 2),
  comparison = rep(c("Genetic|Environment", "Environment|Genetic"), each = length(dist_matrices)),
  statistic = c(map_dbl(genetic_results, "statistic"), map_dbl(envr_results, "statistic")),
  p = c(genetic_p, envr_p),
  p_adj = all_p_adj
)

print(mantel_results)
```

### Assumption check: linearity
```{r assumptions, fig.height=4, fig.width=8}
# check for linearity between predictor and response distances
for (name in names(dist_matrices)) {
  par(mfrow = c(1, 2))
  plot(as.vector(fst_mat), as.vector(dist_matrices[[name]]),
       main = paste("Fst vs", name), xlab = "Fst", ylab = "Response variable distance")
  plot(as.vector(envr_dist), as.vector(dist_matrices[[name]]),
       main = paste("Environment vs", name), xlab = "Environmental distance", ylab = "Response variable distance")
}
```

## Heatmaps
```{r heatmaps, fig.height=10, fig.width=12}
# predictor distance heatmaps
heatmap_fst <- plot_heatmap(fst_mat, expression("Pairwise " * F[ST]))
heatmap_envr <- plot_heatmap(envr_dist, "Standardized Euclidean\nenvironmental distance")

# save predictor heatmaps
ggsave(file.path("figures", "pairwise_differences_analyses", "Fig4A_fst_heatmap.pdf"), heatmap_fst, width = 12, height = 10)
ggsave(file.path("figures", "pairwise_differences_analyses", "Fig4B_envr_dist_heatmap.pdf"), heatmap_envr, width = 12, height = 10)


response_heatmaps <- list(
  FigS10A_length_lew = plot_heatmap(dist_matrices$len_event3_lewisetta, "Euclidean distance\nin shell length"),
  FigS10B_length_york = plot_heatmap(dist_matrices$len_event3_yorkriver, "Euclidean distance\nin shell length"),
  Fig3C_survival_lew = plot_heatmap(dist_matrices$surv_event3_lewisetta, "Euclidean distance\nin survival"),
  Fig3D_survival_york = plot_heatmap(dist_matrices$surv_event3_yorkriver, "Euclidean distance\nin survival")
)

iwalk(response_heatmaps, ~ ggsave(
  file.path("figures", "pairwise_differences_analyses", paste0(.y, "_t3_heatmap.pdf")), 
  .x, width = 12, height = 10
))

# display
heatmap_fst
heatmap_envr
```